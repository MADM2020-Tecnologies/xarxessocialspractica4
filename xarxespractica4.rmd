---
title: "Handout 4"
author: "Guillermo Gavilla Hernández, Miquel Toni Llambías Cabot"
output:
html_document:
toc: true
theme: united
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(tidyverse)
library(igraph)
```


## 1) Generate an undirected random graph using the model of "preferential attachment" (sample_pa( )) of 1000 nodes. With $\beta=0.1$, $\gamma=0.1$, generate a SIR pandemic (iterative method). The initial infected nodes should be the 10 highest using the eigen_centrality( ). Compare the results to when the initial nodes are at random. Reduce or increase $\beta$ and compare.

[help](http://sherrytowers.com/2012/12/11/simple-epidemic-modelling-with-an-sir-model/)
[example](http://www.sherrytowers.com/sir_with_vaccination.R)

### Creamos las funciones

```{r}
states <- c("susceptible", "infected", "recovered", "unknown")
add_states <- function (graph, susceptible, infected, rho) {
  if (!is.null(susceptible)) {
    V(graph)[susceptible]$state <- states[1]
    V(graph)[susceptible]$t_recover <- 0
  }
  if (!is.null(infected)) {
    V(graph)[infected]$state <- states[2]
    V(graph)[infected]$t_recover <- 1/rho
  }
  V(graph)[is.na(V(graph)$state)]$state <- states[4]
  return(graph)
}

do_if_infected <- function (graph, idx, beta, rho, tick) {
  vertex_neighbors <- neighbors(graph = graph, idx)
  for(i in as.numeric(vertex_neighbors)) {
    if (V(graph)$state[i] == states[1]) {
      random <- runif(1, 0, 1)[1]
      if (beta >= random) {
        V(graph)$state[i] <- states[2]
        V(graph)$t_recover[i] <- 1/rho + tick
      }
    }
  }
  return(graph)
}

change_state_infected <- function (graph, beta, rho, tick) {
  for(i in seq_along(V(graph))) {
    if (V(graph)$state[i] == states[2]) {
      graph <- do_if_infected(graph, i, beta, rho, tick)
      if (V(graph)$t_recover[i] <= tick) {
        V(graph)$state[i] <- states[3]
      }
    }
  }
  return(graph)
}

buildSummary <- function (graph, tick) {
  return(data.frame(
          time = tick,
          S = as.numeric(length(V(graph)[V(graph)$state == states[1]])),
          I = as.numeric(length(V(graph)[V(graph)$state == states[2]])),
          R = as.numeric(length(V(graph)[V(graph)$state == states[3]]))
  ))
}

plot_state <- function (graph, state) {
  V(graph)[V(graph)$state == states[1]]$color <- "SkyBlue2"
  V(graph)[V(graph)$state == states[2]]$color <- "red"
  V(graph)[V(graph)$state == states[3]]$color <- "green"
  plot.igraph(graph, vertex.color=V(graph)$color)
}

sir_2 <- function (graph, susceptible, infected, beta, rho, time, per_tick_plot = F) {
  graph <- add_states(graph, susceptible, infected, rho)
  per_tick_summary <- buildSummary(graph, 0)
  if (per_tick_plot){
    plot_state(graph, state)
  }
  for(tick in 1:time) {
    graph <- change_state_infected(graph, beta, rho, tick)
    per_tick_summary <- rbind(per_tick_summary, buildSummary(graph, tick))
    if (per_tick_plot){
      plot_state(graph, state)
    }
  }
  return(per_tick_summary)
}

print_sir_values_2 <- function (sirValues, title = "") {
  with(sirValues, {
    ggplot(data = sirValues, aes(x = time)) +
            ggtitle(title) +
            ylab("Nodes") +
            xlab("Time") +
            geom_line(aes(y = S), color = "blue") +
            geom_line(aes(y = I), color = "red") +
            geom_line(aes(y = R), color = "green") +
            scale_color_discrete(name = "State", labels = c("susceptible", "Infected", "Recovered"))
  })
}
```

#### Probamos que funciona

```{r}
sample_size <- 1000
infected_0 <- 10

prepare_data <- function (size, infected_0) {
  graph <- sample_pa(size, directed = F)
  eigen_values <- data.frame(id = 1: size, values = eigen_centrality(graph)$vector)
  infected <- ((eigen_values[order(eigen_values$values, decreasing = T),])[1:infected_0,])$id
  susceptible <- V(graph)[-infected]
  return(list(graph = graph, infected = infected, susceptible = susceptible))
}

set.seed(7288)
test_data <- prepare_data(30, 5)
sir_2(graph = test_data$graph,
                susceptible = test_data$susceptible,
                infected = test_data$infected,
                beta = 0.8,
                rho = 0.5,
                time = 5,
                per_tick_plot = T) %>%
  print_sir_values_2("test") %>%
  print()
```

#### Comparamos para diferentes betas

```{r}
graph_data <- prepare_data(size = sample_size, infected_0 = infected_0)
for (beta in c(0.01, 0.1, 0.3, 0.5))
{
  sir_2(graph = graph_data$graph,
        susceptible = graph_data$susceptible,
        infected = graph_data$infected,
        beta = beta,
        rho = rho0,
        time = 50) %>%
    print_sir_values_2(paste0("Beta = ", beta)) %>% print()
}
```

Al disminuir $\beta$ ratio de transmisión vemos que los contagios prácticamente no se 'esparcen'. A medida que incrementamos
$\beta$ podemos ver que cada vez son las los que se contagian y más rápido.


En las observaciones anteriores hemos podido ver que para $\beta \epsilon {0.01, 0.1}$ los contagiados no superan a
la población susceptible.

Para $\beta = 0.3$ vemos que se contagia mayor parte de la población, hay un periodo donde
hay mas contagiados que susceptibles o recuperados pero, no llega a contagiar a toda la población. En algún punto la transmisión se corta.

Para $\beta = 0.5$ vemos que la población se contagia muy rápido y se llega a contagiar / recuperar toda.



## 2) Consider the random graph generated in the previous exercise.

### a) Plot its degrees distribution in linear and in log-log scale. Which is more helpful to understand this distribution?


```{r}
library(poweRlaw)
data <- degree(graph_data$graph)
data <- data[data>0]
data.dist <- data.frame(k=0:max(data),p_k=degree_distribution(graph_data$graph))
data.dist <- data.dist[data.dist$p_k>0,]
ggplot(data.dist) + geom_point(aes(x=k, y=p_k)) + theme_bw()
```
```{r}
data.s <- unique(data)

d_est <- data.frame(K_min=sort(data.s)[1:(length(data.s)-2)], gamma=rep(0,length(data.s)-2), D=rep(0,length(data.s)-2))

for (i in d_est$K_min){
  d_est[which(d_est$K_min == i),2] <- estimate_xmin(m_pl, xmins = i)$pars
  d_est[which(d_est$K_min == i),3] <- estimate_xmin(m_pl, xmins = i)$gof
}

K.min_D.min <- d_est[which.min(d_est$D), 1]

ggplot(data=d_est, aes(x=K_min, y=D)) + geom_line() + theme_bw() +
  geom_vline(xintercept=K.min_D.min, colour="red") + annotate("text", x=K.min_D.min, y=max(d_est$D)/3*2, label=K.min_D.min)
```
```{r}
#generate kmin & kmax pairs
pairs <- as.data.frame(t(combn(sort(data.s), 2)))
pairs$D <- rep(0, length(pairs$V1))
pairs$gamma <- rep(0, length(pairs$V1))

#scan D for all kmin-kmax pairs
for (i in seq_along(pairs$D)){
  m_pl$setXmin(pairs[i,1])
  pairs[i,3]<- estimate_xmin(m_pl, xmin = pairs[i,1], xmax = pairs[i,2], distance = "ks")$gof
  pairs[i,4]<- estimate_xmin(m_pl, xmin = pairs[i,1], xmax = pairs[i,2], distance = "ks")$pars
}

bs_pl_sat_cut <- bootstrap_p(m_pl, xmins = pairs[which.min(pairs$D), 1], xmax = pairs[which.min(pairs$D), 2], no_of_sims = 1000, threads = 8)
pairs[which.min(pairs$D), 1] -> k_sat
pairs[which.min(pairs$D), 2] -> k_cut
pairs[which.min(pairs$D), 4] -> gamma
```


```{r}
#powerlaw
m_pl = displ$new(data)
est_pl <- estimate_xmin(m_pl, xmins = k_sat, xmax = k_cut, distance = "ks")
m_pl$setXmin(est_pl)

#lognormal
m_ln = dislnorm$new(data)
est_ln <- estimate_xmin(m_ln)
m_ln$setXmin(est_ln)

#exponential
m_exp = disexp$new(data)
est_exp <- estimate_xmin(m_exp)
m_exp$setXmin(est_exp)

#poisson
m_poi = dispois$new(data)
est_poi <- estimate_xmin(m_poi)
m_poi$setXmin(est_poi)
```

```{r}
plot.new()
plot(m_pl)
lines(m_pl, col="red")
lines(m_ln, col="green")
lines(m_poi, col="blue")
lines(m_exp, col="magenta")
```

Podemos comprobar que para nuestro grafo se adapta mejor la distribución *lognormal* seguida de *powerlaw*.

## b) Does the degree distribution follows a Power Law? What if we consider only the nodes with degree above 5? (or 10? or 100?)


```{r}

```


*c)* Find the best line that approximates the degree distribution after degree 10 (or 5?) using linear regression ( lm() ) on the log-log plane. Don't worry, it is almost all done in the following code. Explain in detail each line of the following code:
```{r, eval=FALSE}
D <- degrees(GRAPH)
xx <- which(D>0)[-(1:10)]  # remove the first 10 prob values
lyy <- log(D[xx])
lxx <- log(xx)
LMI <- lm(lyy~lxx)$coefficients  # line coefficients
plot(D,pch=20,cex=0.7,xlab="Degree",ylab="Frequencies",main="degrees",log="xy")
points(exp(lxx),exp(LMI[1]+LMI[2]*lxx),col="red",type="l",lwd=2)
```



*d)* What is the exponent of the Power Law for the degree probabilities?


**3)** Use the routine sample_pa( ) to generate a rich-get-richer (preferential attachment) graph with similar degree distribution of  the *directed* facebook graph of the file **facebook_sample_anon.txt**. Use the code similar to:
sample_pa(n.GRAPH, out.seq=degree(GRAPH,mode="out"))
Plot the degree distribution of the generated graph (log-log). What is the exponent of the power law of the generated graph for the in-degrees? 