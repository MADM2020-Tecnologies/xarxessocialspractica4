---
title: "Handout 4"
author: "Guillermo Gavilla Hernández, Miquel Toni Llambías Cabot"
output:
html_document:
toc: true
theme: united
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(tidyverse)
library(igraph)
library(deSolve)
```


**1)** Generate an undirected random graph using the model of "preferential attachment" (sample_pa( )) of 1000 nodes. With $\beta=0.1$, $\gamma=0.1$, generate a SIR pandemic (iterative method). The initial infected nodes should be the 10 highest using the eigen_centrality( ). Compare the results to when the initial nodes are at random. Reduce or increase $\beta$ and compare. 

[help](http://sherrytowers.com/2012/12/11/simple-epidemic-modelling-with-an-sir-model/)
[example](http://www.sherrytowers.com/sir_with_vaccination.R)

```{r crear grafo aleatorio}
set.seed(1)
randomGraph <- sample_pa(1000, directed=FALSE)

eigenValues <- as_adjacency_matrix(randomGraph) %>% eigen()

```

```{r function}
t <- 0.1
beta <- 0.1
gamma <- 0.1
x0 <- 0
I <- 0


```


```{r exemple jario sobre SI}
A=matrix(c(0,1,0,1,1,0,0,1,0,0,0,1,1,1,1,0),4)
E=eigen(A)
E$vectors
E$values
A %*% (E$vectors[,1])
E$values[1]*(E$vectors[,1])

t=0.1
beta=0.1
x0=c(0,0,1,0)
I = c(1,1,1,1)

newX <- function (t, beta) {   # algebraic and analytical (approx)
  a0= x0 %*% E$vectors
 
  e=exp(E$values*beta*t)

  coef=a0*e

  R= E$vectors %*% t(coef)
  return(R)
}



newx <- function (x,beta) {   #Iterative
  s = I - x
  return ( x + beta * s * (A %*% x) )
}


n=4
nIter=25
RX=matrix(0,nrow=n,ncol=nIter)
RX[,1]=x0
for (i in 2:(nIter) ){
 RX[,i] = newx(RX[,i-1],beta)
}

x =x0
x=newx(x,beta,0)
x

plot(RX[3,],ylim=c(0.0 , 1.0),col="blue")
par(new=TRUE)
plot(RX[1,],ylim=c(0.0 , 1.0),col="green")
par(new=TRUE)
plot(RX[4,],ylim=c(0.0 , 1.0),col="red")






library(igraph)

G=sample_pa(100,directed=FALSE)

plot(G)
```





**2)** Consider the random graph generated in the previous exercise.

*a)* Plot its degrees distribution in linear and in log-log scale. Which is more helpful to understand this distribution?




*b)* Does the degree distribution follows a Power Law? What if we consider only the nodes with degree above 5? (or 10? or 100?)




*c)* Find the best line that approximates the degree distribution after degree 10 (or 5?) using linear regression ( lm() ) on the log-log plane. Don't worry, it is almost all done in the following code. Explain in detail each line of the following code:
```{r, eval=FALSE}
D <- degree_distribution(GRAPH)
xx <- which(D>0)[-(1:10)]  # remove the first 10 prob values
lyy <- log(D[xx])
lxx <- log(xx)
LMI <- lm(lyy~lxx)$coefficients  # line coefficients
plot(D,pch=20,cex=0.7,xlab="Degree",ylab="Frequencies",main="degrees",log="xy")
points(exp(lxx),exp(LMI[1]+LMI[2]*lxx),col="red",type="l",lwd=2)
```



*d)* What is the exponent of the Power Law for the degree probabilities?


**3)** Use the routine sample_pa( ) to generate a rich-get-richer (preferential attachment) graph with similar degree distribution of  the *directed* facebook graph of the file **facebook_sample_anon.txt**. Use the code similar to:
sample_pa(n.GRAPH, out.seq=degree(GRAPH,mode="out"))
Plot the degree distribution of the generated graph (log-log). What is the exponent of the power law of the generated graph for the in-degrees? 